		device	zxspectrum128


		org	#6000

@ENTRY
levels		incbin	"../levels/levels.bin"
gameplan	incbin	"../gfx/plan.pak"


		org	#8000

C_BG_BRIGHT	equ	1
C_BG_PAPER	equ	7
C_BG_INK	equ	0

LEVEL_CNT	equ	80


start:		di
		ld	sp,start
		ld	a,C_BG_PAPER
		out	(254),a
		call	prepare_info_screen
		call	setup_im2
main_start	call	play

		ld	a,(level+1)
		ld	(tmplevel+1),a
select_level2
maxlevel	ld	a,0
		ld	b,a
		ld	a,(level+1)
		cp	b
		jr	c,.max
		ld	(maxlevel+1),a
.max		; b=currentlevel c=maxlevel
		ld	a,C_BG_PAPER*8+C_BG_PAPER
		call	cls

		ld	e,0
.loop		push	de

		ld	a,e
		ld	c,a	;store level
		ld	hl,txt_nrlevel
		call	level2text

		ld	a,c	;restore level
		call	calc_hl
		add	hl,hl
		add	hl,hl
		add	hl,hl	;*8
		ld	b,h
		ld	c,0
		add	hl,hl	;*16
		add	hl,bc	;*24
		ld	bc,0x2512
		add	hl,bc

		ld	b,l		;top
		ld	c,h		;left
		ld	a,16		;width
		ld	hl,txt_nrlevel
		call	print_text_centered

		pop	de

		call	highlight_level
		inc	e
		ld	a,e
		cp	LEVEL_CNT
		jr	c,.loop
level_select	call	get_key
		cp	K_BREAK
		jr	z,level_continue
		cp	K_EDIT
		jr	z,level_continue
		cp	K_SPACE
		jr	z,level_play
		cp	K_ENTER
		jr	z,level_play
		cp	'o'
		jr	z,level_down	;5
		cp	'a'
		jr	z,level_pgup	;6
		cp	'q'
		jr	z,level_pgdown	;7
		cp	'p'
		jr	nz,level_select	;8
;level_up
		ld	a,(maxlevel+1)
		ld	e,a
		ld	a,(level+1)
		cp	e
		jr	nc,level_select
		ld	e,a
		inc	a
		jr	level_set

level_down	ld	a,(level+1)
		or	a
		jr	z,level_select
		ld	e,a
		dec	a
		jr	level_set

level_pgup	ld	a,(maxlevel+1)
		ld	e,a
		ld	a,(level+1)
		add	a,7
		cp	e
		jr	nc,level_select
		ld	a,(level+1)
		ld	e,a
		add	a,8
		jr	level_set

level_pgdown	ld	a,(level+1)
		cp	8
		jr	c,level_select
		ld	e,a
		sub	8
		jr	level_set

level_set	ld	(level+1),a
		call	highlight_level
		ld	a,(level+1)
		ld	e,a
		call	highlight_level
		call	key_delay
		jr	level_select
		ret

level_play	ld	a,(tmplevel+1)
		ld	e,a
		ld	a,(level+1)
		cp	e
		jp	nz,main_start

level_continue
		ld	a,(tmplevel+1)
		cp	255
		jp	z,main_start
		ld	(level+1),a
		jp	main_start

calc_hl		ld	hl,255
.loop		sub	8
		inc	l
		jr	nc,.loop
		add	a,8
		ld	h,a
		ret

highlight_level
		ld	a,(maxlevel+1)
		cp	e
		ld	d,5+7*8
		jr	c,.next
		ld	a,(level+1)
		cp	e
		ld	d,2+7*8
		jr	z,.next
		ld	d,0+7*8
.next		ld	a,e
		call	calc_hl

		ld	b,h
		ld	c,0
		add	hl,hl	;*2
		add	hl,bc
		ld	bc,0x0400
		add	hl,bc
		ld	c,h
		ld	b,0
		ld	h,b

		add	hl,hl
		add	hl,hl
		add	hl,hl
		add	hl,hl
		add	hl,hl
		add	hl,bc
		ld	bc,22528+64
		add	hl,bc

		ld	(hl),d
		inc	hl
		ld	(hl),d
		inc	hl
		ld	(hl),d
		ld	bc,32-2
		add	hl,bc

		ld	(hl),d
		inc	hl
		ld	(hl),d
		inc	hl
		ld	(hl),d
		ret

cls		ld	hl,#4000
		ld	de,#4001
		ld	bc,#1800
		ld	(hl),l
		ldir
		ld	(hl),a
		ld	bc,#2ff
		ldir
		ret

play		ld	a,C_BG_PAPER
		out	(254),a

		ld	hl,gameplan
		ld	de,#4000
		call	unpack

start_level
.nokey		xor	a
		in	a,(254)
		cpl
		and	31
		jr	nz,.nokey
		halt

level		ld	a,0
tmplevel	cp	255
		jr	z,.tmp

		;load level and print it to the screen
;		call	prepare_level
;		jp	c,game_end

		ld	hl,play_area
		ld	de,undo_area
		ld	bc,8*10*5
		ldir
		jr	.legend

.tmp		ld	a,255
		ld	(tmplevel+1),a

.legend		ld	a,(level+1)	;level
		ld	hl,txt_nrlevel
		call	level2text

		ld	b,6		;top
		ld	c,256-32	;left
		ld	a,32		;width
		ld	hl,txt_nrlevel
		call	print_text_centered

		ld	b,18		;top
		ld	c,256-32	;left
		ld	a,32		;width
		ld	hl,txt_level
		call	print_text_centered

mainloop	call	get_key
		cp	'c'		;level code
		jp	z,entercode

		cp	'm'		;music off/on
		jp	z,manage_music

		cp	'i'		;info
		jp	z,info_screen

		cp	'u'		;undo
		jr	z,perform_undo

		cp	'l'		;select level
		ret	z

		cp	'r'		;reload
		jp	z,start_level

		cp	'1'
		jr	c,mainloop_cont
		cp	'5'
		jr	nc,mainloop_cont

		sub	48

		scf
;		call	perform_move
		jr	c,mainloop_cont	;cannot move

;		call	test_level_done
		jp	nc,next_level	;level done

		ld	hl,play_area+8*10*5-1
		ld	de,undo_area+8*10*5-1
		ld	bc,8*10*5
		lddr
mainloop_cont
		call	key_delay
		jr	mainloop
manage_music
		call	mute_unmute
		jr	mainloop_cont
perform_undo
		call	undo
		jr	mainloop_cont

undo		ld	hl,undo_area+8*10
		ld	de,undo_area
		ld	bc,8*10*4
		ldir
		ret

entercode	call	key_delay
		call	fadeout

		ld	a,C_BG_PAPER*8 + C_BG_INK
		call	cls

		ld	hl,enterlevelcodetxt
		ld	b,12*7
		ld	c,0
		ld	a,0		;width
		call	print_text_centered

		call	fadein

		ld	hl,tmpcode
		ld	(hl),0
		ld	b,8

.loop		push	bc
		push	hl

.getkey		call	get_key
		or	a
		jr	z,.getkey

		cp	13
		jr	z,.end1
		cp	'0'
		jr	c,.getkey
		cp	'f'+1
		jr	nc,.getkey
		cp	'9'+1
		jr	c,.keyok
		cp	'a'
		jr	c,.getkey
		sub	32

.keyok		pop	hl
		ld	(hl),a
		inc	hl
		ld	(hl),0

		push	hl
		ld	hl,tmpcode
		ld	b,12*8
		ld	c,0
		ld	a,0		;width
		call	print_text_centered
		pop	hl

		call	key_delay

		pop	bc
		djnz	.loop

		ld	hl,tmpcode
		ld	de,levelhashtext2
		ld	bc,8
		ldir
		call	get_level_code
		jr	c,.end

		call	decode_level_code
		jr	c,.end
		or	a
		jr	z,.end
		cp	LEVEL_CNT

		jr	nc,.end

		ld	(level+1),a
		ld	c,a
		ld	a,(maxlevel+1)
		cp	c		;entered code
		jr	nc,.nochg_max

		;entered code is bigger than max, so update max
		ld	(maxlevel+1),a

.nochg_max	ld	a,255
		jr	.set

.end1		pop	bc
		pop	hl
.end		ld	a,(level+1)

.set		ld	(tmplevel+1),a

		call	fadeout
		ld	a,C_BG_PAPER*8 + C_BG_INK
		call	cls
		call	fadein
		jp	start_level

key_delay	ld	b,20
.loop		halt
		xor	a
		in	a,(254)
		cpl
		and	31
		ret	z
		djnz	.loop
		ret

level2text	inc	a
		ld	e,48
.loop		sub	10
		jr	c,.next
		inc	e
		jr	.loop
.next		add	a,58
		ld	d,a
		ld	a,e
		cp	48
		jr	z,.finish
		ld	(hl),e
		inc	hl
.finish		ld	(hl),d
		inc	hl
		ld	(hl),0
		ret

next_level	ld	a,255
		ld	(tmplevel+1),a

		ld	hl,22528+4
		ld	de,8
		ld	c,24
.rows		ld	b,24
.cols		res	6,(hl)
		inc	hl
		djnz	.cols

		add	hl,de
		dec	c
		jr	nz,.rows

		ld	b,50
.waitsec	halt
		djnz	.waitsec

		ld	a,(level+1)
		ld	hl,level_texts
.mainloop	push	hl
		call	fadeout

		ld	a,0		;width
		call	print_text_screen_centered

		pop	hl
.findnz		ld	a,(hl)
		inc	hl
		or	a
		jr	nz,.findnz

		ld	a,(hl)
		or	a
		jr	nz,.next

		ld	a,(level+1)
		inc	a
		ld	(level+1),a
		cp	LEVEL_CNT
		jr	nc,.next

		push	hl

		call	encode_level_code
		call	translate_level_code

		ld	hl,levelhashtext
		call	get_width

		ld	a,255
		sub	e
		ld	c,a
		ld	b,180
		call	set_position
		ld	hl,levelhashtext
		call	print_text

		pop	hl
.next		push	hl

		call	fadein
.wkey		call	get_key
		or	a
		jr	z,.wkey

		pop	hl
		ld	a,(hl)
		or	a
		jr	nz,.mainloop

;		jp	start_level
		jp	play
game_end
		ld	a,(level+1)
		dec	a
		ld	(level+1),a
		ld	a,255
		ld	(tmplevel+1),a
		pop	hl
		jp	select_level2
		ret

fadeout		push	hl
		ld	d,7
.clrloop	halt
		ld	hl,22528
		ld	bc,768
.scrloop	ld	a,(hl)
		and	63
		ld	e,a
		and	7
		cp	7
		jr	z,.ink
		inc	e
.ink		ld	a,e
		and	56
		cp	56
		jr	z,.paper
		ld	a,e
		add	a,8
		ld	e,a
.paper		ld	(hl),e
		inc	hl
		dec	bc
		ld	a,b
		or	c
		jr	nz,.scrloop

		dec	d
		jr	nz,.clrloop

		ld	a,C_BG_PAPER*8+C_BG_PAPER
		call	cls
		pop	hl
		ret

fadein		push	hl
		ld	d,7
.clrloop	halt
		ld	hl,22528
		ld	bc,768
.scrloop	ld	a,(hl)
		and	7
		jr	z,.max
		dec	(hl)
.max		inc	hl
		dec	bc
		ld	a,b
		or	c
		jr	nz,.scrloop

		dec	d
		jr	nz,.clrloop
		pop	hl
		ret

get_key		ld	hl,keys
		ld	bc,0xfefe
		in	a,(c)
		rra
		jr	c,.test
		ld	hl,keys.caps
.test		ld	d,8
		rrc	b
.rows		in	a,(c)
		rlca
		rlca
		rlca
		ld	e,5
.cols		rlca
		jr	c,.next
		ld	a,(hl)
		ret

.next		inc	hl
		dec	e
		jr	nz,.cols
		rrc	b
		dec	d
		jr	nz,.rows
		jr	get_key

		include "keymap.inc"

set_font	ld	(font),hl
		ret
set_position	ld	a,b
		ld	(ycoord),a
		ld	a,c
		ld	(xcoord),a
		ret

get_width	ld	de,0
.loop		ld	a,(hl)
		or	a
		ret	z
		cp	13
		ret	z

		sub	32
		ld	c,a
		ld	b,0
		push	hl
		ld	hl,(font)
		add	hl,bc
		ld	l,(hl)
		ld	h,0
		add	hl,de
		ex	de,hl
		pop	hl
		inc	hl
		jr	.loop

print_text_screen_centered
		push	af
		push	hl

		;calculate left border from width: c=(256-a)/2
		ld	c,a
		xor	a
		sub	c
		srl	a
		ld	c,a

		;calculate number of lines
		ld	b,1
.lines		ld	a,(hl)
		or	a
		jr	z,.done
		cp	13
		jr	nz,.noent
		inc	b
.noent
		inc	hl
		jr	.lines
.done
		;calculate top border from nr of lines: b=(192-12*L)/2
		ld	a,b
		add	a,b	;*2
		add	a,b	;*3
		add	a,a	;*6
		add	a,a	;*12

		ld	b,a
		ld	a,192
		sub	b
		srl	a
		ld	b,a

		pop	hl
		pop	af

print_text_centered
		push	hl
.loop		push	af
		push	bc

		push	hl
		push	bc
		push	af

		call	get_width
		srl	e	;width of text /2

		pop	af
		or	a
		jr	nz,.div
		ld	a,128	;widht 0 means 256, so width/2 = 128
		jr	.nodiv
.div		srl	a	;width of "window" /2
.nodiv		pop	bc

		add	a,c
		sub	e
		ld	c,a
		call	set_position
		pop	hl
		push	hl
		call	print_text
		pop	hl

.getline	ld	a,(hl)
		inc	hl
		or	a
		jr	z,.eol
		cp	13
		jr	nz,.getline
		pop	bc
		ld	a,12
		add	a,b
		ld	b,a
		pop	af
		jr	.loop

.eol		pop	bc
		pop	af
		pop	hl
		ret

print_text	ld	a,(hl)
		or	a
		ret	z
		cp	13
		ret	z

		push	hl
		sub	32
		ld	e,a
		ld	d,0
		ld	hl,(font)
		add	hl,de
		ld	a,(xcoord)
		add	a,(hl)
		jr	nc,.print1

		xor	a
		ld	(xcoord),a

		ld	a,(ycoord)
		add	a,12
		cp	192
		jr	c,.sameln1
		sub	192
.sameln1	ld	(ycoord),a
.print1		pop	hl
		push	hl
		ld	a,(hl)
		call	print_char
		pop	hl
		push	hl

		ld	a,(hl)
		sub	32
		ld	e,a
		ld	d,0
		ld	hl,(font)
		add	hl,de
		ld	a,(xcoord)
		add	a,(hl)
		ld	(xcoord),a
		jr	nc,.print2

		xor	a
		ld	(xcoord),a
		ld	a,(ycoord)
		add	a,12
		cp	192
		jr	c,.sameln2
		sub	192
.sameln2	ld	(ycoord),a
.print2		pop	hl
		inc	hl
		jr	print_text

print_char	sub	32
		ld	e,a
		ld	d,0
		ld	hl,(font)
		add	hl,de
		ld	b,(hl)	;width

		ld	a,b
		or	a
		ret	z	;zero width???

		ld	bc,0xffff
		ld	d,0xff
.rot1		srl	b
		rr	c
		rr	d
		dec	a
		jr	nz,.rot1
		ld	a,(xcoord)
		and	7
		jr	z,.norot

.rot2		scf
		rr	b
		rr	c
		rr	d
		dec	a
		jr	nz,.rot2
.norot		ld	a,d
		ld	(fatfontfix+1),a
		ld	d,0

		;we have character mask in bc
		ld	l,e
		ld	h,d
		add	hl,hl	;*2
		add	hl,de	;*3
		add	hl,hl	;*6
		add	hl,hl	;12
		ld	de,126
		add	hl,de
		ld	de,(font)
		add	hl,de
		;we have font address in hl
		ld	a,(xcoord)
		rrca
		rrca
		rrca
		and	31
		ld	e,a

		ld	a,(ycoord)
		ld	d,a
		rlca
		rlca
		and	0xe0
		or	e
		ld	e,a
		ld	a,d
		and	0xc7
		ld	d,a
		rrca
		rrca
		rrca
		or	d
		and	31
		or	64
		ld	d,a
		;we have screen address in de

		ld	a,12
print_loop	push	af
		push	hl

		ld	h,(hl)
		ld	l,0

		ld	a,(xcoord)
		and	7
		jr	z,.norot
.rot		srl	h
		rr	l
		dec	a
		jr	nz,.rot
.norot		ld	a,(de)
		and	b
		or	h
		ld	(de),a
		inc	de
		ld	a,(de)
		and	c
		or	l
		ld	(de),a
		inc	de
		ld	a,(de)
fatfontfix	and	0
		ld	(de),a
		dec	de
		dec	de
		call	downde
		pop	hl
		inc	hl
		pop	af
		dec	a
		jr	nz,print_loop
		ret

downde		inc	d
		ld	a,d
		and	7
		ret	nz
		ld	a,e
		add	a,32
		ld	e,a
		ld	a,d
		jr	c,.chkovr
		sub	8
		ld	d,a
		ret
.chkovr		cp	88
		ret	c
		ld	d,64
		ret

encode_level_code
		ld	ix,levelhash
		ld	d,a

		ld	a,r
		ld	l,a
		ld	h,0
		ld	e,8
		ld	bc,levelhash
.loop1		ld	a,(hl)
		and	15
		ld	(bc),a
		inc	hl
		inc	bc
		dec	e
		jr	nz,.loop1

		ld	hl,levelhashbits
		ld	c,2
.loop2		ld	e,d
		ld	b,6
.loop3		ld	a,(hl)
		and	7
		ld	(.lvlsetres+2),a	;calculate offset

		ld	a,(hl)
		and	24		;calculate bit
		rrc	e
		jr	nc,.setres	;set/reset
		or	64
.setres		or	128+6
		ld	(.lvlsetres+3),a

		;1 V BBB 110
		;res	n,(ix+m)	dd cb mm n*8+0x86
		;set	n,(ix+m)	dd cb mm n*8+0xc6
.lvlsetres	set	0,(ix+0)	;bit and offset is calculated
		inc	hl
		djnz	.loop3

		ld	a,d
		cpl
		ld	d,a

		dec	c
		jr	nz,.loop2
		ret

decode_level_code
		ld	ix,levelhash
		ld	e,0
		ld	hl,levelhashbits
		ld	c,2
.loop1		ld	d,e
		ld	e,0
		ld	b,6
.loop2		ld	a,(hl)
		and	7
		ld	(.levelbit+2),a	;calculate offset

		ld	a,(hl)
		and	24		;calculate bit
		or	64+6		;bit
		ld	(.levelbit+3),a

		rrc	e
		;01 BBB 110
		;bit	n,(ix+m)	dd cb mm n*8+0x46
.levelbit	bit	0,(ix+0)
		jr	z,.setres
		set	5,e
.setres		inc	hl
		djnz	.loop2

		dec	c
		jr	nz,.loop1
		ld	a,e
		cpl
		and	63
		cp	d
		ret	z
		xor	a
		scf
		ret

translate_level_code
		ld	hl,levelhash
		ld	de,levelhashtext2
		ld	b,8
.loop		ld	a,(hl)
		and	15
		add	a,'0'
		cp	'0'+10
		jr	c,.dec
		add	a,'A'-'0'-10
.dec		ld	(de),a
		inc	hl
		inc	de
		djnz	.loop
		ret

get_level_code
		ld	hl,levelhashtmp
		ld	de,levelhashtext2
		ld	b,8
.loop		ld	a,(de)
		cp	'0'
		jr	c,get_level_code_err	; <0,'0')

		cp	'F'+1
		jr	nc,get_level_code_err	; ('F',255>

		cp	'9'+1
		jr	c,.dec			; <'0','9'>

		cp	'A'
		jr	c,get_level_code_err	; ('9','A')

						; <'A','F'>
		sub	7
.dec		sub	'0'
		ld	(hl),a
		inc	hl
		inc	de
		djnz	.loop

		ld	hl,levelhashtmp
		ld	de,levelhash
		ld	bc,8
		ldir
		or	a
		ret

get_level_code_err
		scf
		ret


HASHBIT		macro	b,o
		db	b*8+o
		endm

levelhashbits
		HASHBIT	 0,1
		HASHBIT	 0,6
		HASHBIT	 1,0
		HASHBIT	 3,3
		HASHBIT	 2,5
		HASHBIT	 3,4

		HASHBIT	 2,6
		HASHBIT	 1,2
		HASHBIT	 1,3
		HASHBIT	 0,7
		HASHBIT	 1,4
		HASHBIT	 2,1

prepare_info_screen
		ld	a,C_BG_PAPER*8+C_BG_PAPER
		call	cls

		xor	a
		ld	hl,info_text
		ld	b,90
		call	print_text_screen_centered

		ld	hl,#4000
		ld	de,precalcscr
		ld	bc,#1800
		ldir

		ret

info_screen	ld	a,(level+1)
		ld	(tmplevel+1),a

		ld	a,7*8
		call	cls

		call	fadeout

		ld	hl,precalcscr
		ld	de,#4000
		ld	bc,#1800
		ldir

		call	fadein
.wkey		call	get_key
		or	a
		jr	z,.wkey
		jp	play

mute_unmute	ld	a,(music_muted)
		xor	1
		ld	(music_muted),a
		and	1
		ret	z
		call	music_stop
		ret

setup_im2	di

		;prepare im2 table
		ld	hl,0xbe00
		ld	de,0xbe01
		ld	bc,0x0100
		ld	(hl),0xbf
		ldir

		;prepare jump to im2 routine
		ld	a,0xc3	;jp
		ld	hl,im2_rut
		ld	(0xbfbf),a
		ld	(0xbfc0),hl

		;setup I reg
		ld	a,0xbe
		ld	i,a

		;and switch to im2
		im	2

		;init music
		call	music_init

		;and enable interrupt
		ei
		ret

im2_rut		push	ix
		push	iy
		push	hl
		push	de
		push	bc
		push	af
		exx
		ex	af,af'
		push	hl
		push	de
		push	bc
		push	af

		ld	a,(music_muted)
		rrca
		jr	c,.muted
		call	music_play

.muted		pop	af
		pop	bc
		pop	de
		pop	hl
		ex	af,af'
		exx
		pop	af
		pop	bc
		pop	de
		pop	hl
		pop	iy
		pop	ix

		ei
		ret


;;-----------------------------------------------------------------------------
;; Setting for depacker according to compression identification -tXYoAoB

com	=	3	;; Compression type - one from TYPZX7 TYPBLK TYPBS1
pos	=	4	;; Offset coding - one from POSOF4 POSOF1 POSOF2 POSOFD
ofs1	=	3	;; Number of bits for 1st offset - required for POSOF1 POSOF2 POSOF4
ofs2	=	0	;; Number of bits for 2nd offset - required for POSOF2 only

;; This is needed to set according to compression ID string from name of compressed file:
;;  -tXYoAoB ... means setting  com=X, pos=Y, ofs1=A, ofs2=B   (ofs1 ofs2 only when required)

;; Set optimization of depacker
spd	=	2

;; Possible values:
;;  0 ... optimized for code length - short but slow
;;  1 ... compromise between length and speed
;;  2+ .. optimized for speed - but longer code

unpack:		include "lzx.a80"

		include "music.a80"

;;-----------------------------------------------------------------------------

enterlevelcodetxt
		db	"Enter code:",0
tmpcode		db	"146011EB",0

levelhashtmp	db	"00000000"
levelhash	db	"00000000",0
levelhashtext	db	"Code: "
levelhashtext2	db	"        ",0

txt_nrlevel	db	0,0,0
txt_level	db	"level",0

level_texts	db	"Well done!",0,0
		db	0			;end of all level texts

info_text	db	"COLORISTIC",13
		db	"(ZX-Spectrum version)",13
		db	13
		db	"game idea & level design:",13
		db	"Daniel Krautwurst",13
		db	"[coloristic-game.com]",13
		db	13, 13
		db	"code, graphics, music, intro screen:",13
		db	"mborik",13
		db	13
		db	"user interface engine: ub880d",13
		db	"font: Proxima Software & ub880d",13
		db	13
		db	"betatesters: ub880d, rombor, ikon",13
		db	0

xcoord		db	0
ycoord		db	0

music_muted	db	0

font		dw	font1
font1		incbin	"../gfx/ladybird.fnt"


		include "sprites.inc"

@TOTAL_LENGTH = $-ENTRY

play_area	ds	8*10
undo_area	ds	8*10*5

precalcscr = #E800


		savebin "coloristic.bin",ENTRY,TOTAL_LENGTH
		savesna "../coloristic.sna",start
